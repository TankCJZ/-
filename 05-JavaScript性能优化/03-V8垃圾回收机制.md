## `V8` 引擎特点
* `V8` 是主流的 `JavaScript` 执行引擎，在 `Chrome` 浏览器中就使用了 `V8`
* `V8` 采用的是即时编译(`JIT`)也即是动态编译，在代码运行阶段可以编译，有性能加成
* `V8` 内存有限制，应该是在浏览器中使用，所以限制了最大内存上限64位系统(1.5G),32位系统(800M)

## `V8` 垃圾回收策略
* 内存分代回收的思想：也就是将内存分为两代，新生代和老生代，并且针对不同分代采用不同回收算法。

## `V8` 常用的 `GC` 算法
* 分代回收
* 空间复制
* 标记清除
* 标记整理
* 标记增量

## 新生代回收
`V8` 中会将内存一分为二，分为一大一小的空间，小空间用来储存新生代对象，新生代指的是存放时间较短的对象。你可以理解为临时对象。例如函数中定义的对象，通常在执行完函数就会回收，这类就是新生代。
新生代回收算法采用的是：**复制算法+标记整理**：   
* 首先会将新生代内存一分为二,分成两个等大小空间,为 `from` 和  `to`
* `form` 空间用来储存对象，`to` 空闲，当前使用的是 `form` 空间
* 当触发垃圾回收就会将活动对象标整理，然后复制到 `to` 空间中
* 接着 `form` 和 `to` 空间进行交换
* 完成交换后即可释放空间

**晋升操作**   
* 如果拷贝过程中，发现新生代中的对象在老生代中也存在，就会产生晋升操作，对象会被移动到老生代，这个过程叫做晋升。
* 如果新生代经过一轮 `GC` 后还存活的新生代对象会被晋升到老生代中。
* 如果在拷贝过程中发现 `to` 空间的使用率超过了 `25%` 也会将所有活动对象移动到老生代中。

## 老生代回收
老生代则是一分二中大空间，这个空间也存在最高上限(64位系统1.4G),(32位系统700M)，老生代指的是储存活动时间较长的对象。比如说闭包中的一些对象存活时间可能较长则会在老生代中。   
老生代采用的是 **标记清除、标记整理、增量标记**算法:   
* 首先会采用标记清除算法来回收空间，找到活动对象并清除释放空间
* 当接受到新生代晋升的对象，并且当前空间不足的时候则会采用标记整理方式，整理空间后再回收，最后会采用增量标记进行效率优化。

> 增量标记：再标记过程中分多次完成，因为标记会堵塞 `JavaScript` 执行，全量标记可能会消耗太多时间。所以通常情况下采用标记清除就可以，除非是在空间不够才会进行标记整理清除算法。

## 新老生代对比
* 新生代采用的是空间换时间，数据小复制快，效率高。
* 老生代垃圾回收不适合用复制算法，因为空间太大了，会造成浪费，并且数据多复制效率不高。

## 总结
`V8` 是主流的 `JavaScript` 引擎，因为为浏览器使用，有内存上限。采用分代的垃圾回收思想，新生代占用(16M/32M)，老生代(700M/1.4G)空间。新生代采用 **复制+标记整理**，老生代采用 **编辑清除、标记整理+增量标记** 算法。新生代存放存活时间短的对象，例如函数中对象。老生代存放时间长的对象，例如 闭包。